
"-------------------------------------------------------------------------------
" Quickrun
"-------------------------------------------------------------------------------

" let g:quickrun_config = {}
"   " openblowserでブラウザ表示 + markdown
" let g:quickrun_config['markdown'] = {
"   \ 'type': 'markdown/kramdown',
"   \ 'outputter': 'browser'
"   \ }
" let g:quickrun_config['quickrun'] = {
"   \ 'outputter': 'browser'
"   \ }
"-------------------------------------------------------------------------------
" Unite
"-------------------------------------------------------------------------------

" let g:unite_enable_start_insert = 1
  " UniteのデータはDropbox上に置く
" let g:unite_data_directory            = '~/Dropbox/work/dotfiles/vim/unite'
  let g:unite_source_file_mru_limit = 200
  call unite#custom_default_action('file', 'tabopen')
  " Unite bookmark のアクションを vimfiler にした
  call unite#custom_default_action('source/bookmark/directory' , 'vimfiler')

  autocmd FileType unite call s:unite_my_settings()
    function! s:unite_my_settings()  "{{{
      " Overwrite settings.
    nmap <silent><buffer> <C-c><C-c> q
      imap <silent><buffer> <C-c><C-c> <C-c>q
      imap <buffer> jj      <Plug>(unite_insert_leave)
      imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)
      " ウィンドウを分割して開く
      nnoremap <silent> <buffer> <expr> <C-s> unite#do_action('split')
      inoremap <silent> <buffer> <expr> <C-s> unite#do_action('split')
      " ウィンドウを縦に分割して開く
      nnoremap <silent> <buffer> <expr> <C-v> unite#do_action('vsplit')
      inoremap <silent> <buffer> <expr> <C-v> unite#do_action('vsplit')
    endfunction "}}}


"" unite-grep {{{
" unite-grepのバックエンドをagに切り替える
" http://qiita.com/items/c8962f9325a5433dc50d
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts = '--nocolor --nogroup'
let g:unite_source_grep_recursive_opt = ''
let g:unite_source_grep_max_candidates = 200

" unite-grepのキーマップ
" 選択した文字列をunite-grep
" https://github.com/shingokatsushima/dotfiles/blob/master/.vimrc
vnoremap /g y:Unite grep::-iHRn:<C-R>=escape(@", '\\.*$^[]')<CR><CR>
" }}}



"-------------------------------------------------------------------------------
" vimfiler
"-------------------------------------------------------------------------------

  " vimfilerをデフォルトファイラへ
  let g:vimfiler_as_default_explorer = 1
  " セーフモード OFF (削除やリネームをサクサクしたい)
  let g:vimfiler_safe_mode_by_default = 0
  " file_mruの表示フォーマットを指定。空にすると表示スピードが高速化される
  " let g:unite_source_file_mru_filename_format = ''
  let g:vimfiler_edit_action = 'tabopen'
"-------------------------------------------------------------------------------
" YankRing.vim
"-------------------------------------------------------------------------------

  " Yankの履歴参照
" nmap ,y ;YRShow<CR>


"-------------------------------------------------------------------------------
" grep.vim
"-------------------------------------------------------------------------------

  " 検索外のディレクトリ、ファイルパターン
  " let Grep_Skip_Dirs = '.svn .git .hg'
  " let Grep_Skip_Files = '*.bak *~'

"-------------------------------------------------------------------------------
" Fugitive.vim
"-------------------------------------------------------------------------------

nnoremap <Space>gd :<C-u>Gdiff<Enter>
nnoremap <Space>gs :<C-u>Gstatus<Enter>
nnoremap <Space>gl :<C-u>Glog<Enter>
nnoremap <Space>ga :<C-u>Gwrite<Enter>
nnoremap <Space>gc :<C-u>Gcommit<Enter>
nnoremap <Space>gC :<C-u>Git commit --amend<Enter>
nnoremap <Space>gb :<C-u>Gblame<Enter>


"-------------------------------------------------------------------------------
" Zen-Coding(Emmet)
"-------------------------------------------------------------------------------

let g:user_emmet_expandabbr_key = '<tab>'
let g:use_emmet_complete_tag = 1
let g:user_emmet_settings = {
  \  'lang' : 'ja',
  \  'html' : {
  \    'filters' : 'html',
  \    'indentation' : ' '
  \  },
  \  'php' : {
  \    'extends' : 'html',
  \    'filters' : 'html,c',
  \  },
  \  'css' : {
  \    'filters' : 'fc',
  \  },
  \  'javascript' : {
  \    'snippets' : {
  \      'jq' : "$(function() {\n\t${cursor}${child}\n});",
  \      'jq:each' : "$.each(arr, function(index, item)\n\t${child}\n});",
  \      'fn' : "(function() {\n\t${cursor}\n})();",
  \      'tm' : "setTimeout(function() {\n\t${cursor}\n}, 100);",
  \    },
  \  },
  \}



"-------------------------------------------------------------------------------
" neocomplete
"-------------------------------------------------------------------------------


"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'


" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'php' : $DOTVIM.'/dict/php.dict'
        \ }


"    \ 'vimshell' : $HOME.'/.vimshell_hist',
"    \ 'scheme' : $HOME.'/.gosh_completions',
"    \ 'ruby' : $DOTVIM.'/dict/ruby.dict',
"    \ 'javascript' : $DOTVIM.'/dict/javascript.dict',
"    \ 'lua' : $DOTVIM.'/dict/lua.dict',

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
" inoremap <expr><C-g>     neocomplete#undo_completion()
" inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplete#smart_close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
"let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'


" neosnippetの優先度を上げる
call neocomplete#custom_source('neosnippet', 'rank',  400)

"-------------------------------------------------------------------------------
" Syntastic
"-------------------------------------------------------------------------------

  " エラー行をsignで表示する
  let g:syntastic_enable_signs = 1
  " 可能ならhighligt表示する
  let g:syntastic_enable_highlighting = 1
  let g:syntastic_php_checkers=['php', 'phpcs', 'phpmd']
  " let g:syntastic_php_phpcs_args='--standard=psr2'
  let g:syntastic_php_phpcs_post_args='--standard=psr2'




"-------------------------------------------------------------------------------
" LightLine
"-------------------------------------------------------------------------------

set laststatus=2
" set t_Co=256 " explicit 256 color support

let g:lightline = {
        \ 'colorscheme': 'solarized',
        \ 'mode_map': {'c': 'NORMAL'},
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ]
        \ },
        \ 'component_function': {
        \   'modified': 'MyModified',
        \   'readonly': 'MyReadonly',
        \   'fugitive': 'MyFugitive',
        \   'filename': 'MyFilename',
        \   'fileformat': 'MyFileformat',
        \   'filetype': 'MyFiletype',
        \   'fileencoding': 'MyFileencoding',
        \   'mode': 'MyMode'
        \ }
        \ }

function! MyModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
endfunction

function! MyFilename()
  return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
        \  &ft == 'unite' ? unite#get_status_string() :
        \  &ft == 'vimshell' ? vimshell#get_status_string() :
        \ '' != expand('%') ? expand('%') : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  try
    if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      return fugitive#head()
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 150 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 150 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 150 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  return winwidth(0) > 60 ? lightline#mode() : ''
endfunction


"-------------------------------------------------------------------------------
" tabline
"-------------------------------------------------------------------------------
"
set showtabline=2 " 常にタブラインを表示

" set tabline=%!MakeTabLine()
" 
" function! MakeTabLine() "{{{
"   let titles = map(range(1, tabpagenr('$')), 's:tabpage_label(v:val)')
"   let sep = ' '  " タブ間の区切り
"   let tabpages = join(titles, sep) . sep . '%#TabLineFill#%T'
"   let info = ''  " 好きな情報を入れる
" 
"   "FoldCCnavi
"   if exists('*FoldCCnavi')
"     let info .= '%#TabLineInfo#'.substitute(FoldCCnavi()[-60:],'\s>\s','%#TabLineFill#> %#TabLineInfo#','g').'%0* '
"   endif
" 
"   "カレントディレクトリ
"   let info .= '['.fnamemodify(getcwd(), ":~") . ']'
" 
"   return tabpages . '%=' . info  " タブリストを左に、情報を右に表示
" endfunction "}}}
" 
" 
" function! s:tabpage_label(tabpagenr) "{{{
"   "rol;各タブページのカレントバッファ名+αを表示
"   let title = gettabvar(a:tabpagenr, 'title') "タブローカル変数t:titleを取得
"   if title !=# ''
"     return title
"   endif
" 
"   " タブページ内のバッファのリスト
"   let bufnrs = tabpagebuflist(a:tabpagenr)
" 
"   " カレントタブページかどうかでハイライトを切り替える
"   let hi = a:tabpagenr is tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
" 
"   " バッファが複数あったらバッファ数を表示
"   let no = len(bufnrs)
"   if no is 1
"     let no = ''
"   endif
"   " タブページ内に変更ありのバッファがあったら '+' を付ける
"   let mod = len(filter(copy(bufnrs), 'getbufvar(v:val, "&modified")')) ? '+' : ''
"   let nomod = (no . mod) ==# '' ? '' : '['.no.mod.']'
" 
"   " カレントバッファ
"   let curbufnr = bufnrs[tabpagewinnr(a:tabpagenr) - 1]  " tabpagewinnr() は 1 origin
"   let fname = fnamemodify(bufname(curbufnr), ':t')
"   let fname = fname is '' ? 'No title' : fname "バッファが空ならNo title
" 
"   let label = fname . nomod
" 
"   return '%' . a:tabpagenr . 'T' . hi .a:tabpagenr.': '. curbufnr.'-' . label . '%T%#TabLineFill#'
" endfunction "}}}






















"-------------------------------------------------------------------------------
" tcomment_vim
"-------------------------------------------------------------------------------

let g:tcommentMapLeader1 = '<C-_>'     "     (default: '<c-_>')
let g:tcommentMapLeader2 = '<Leader>'  "        (default: '<Leader>_')
" let g:tcommentMapLeaderOp1 = 'gc'      "  (default: 'gc')
" let g:tcommentMapLeaderOp2 = 'gC'      "  (default: 'gC')


" tcommentで使用する形式を追加
if !exists('g:tcomment_types')
  let g:tcomment_types = {}
endif
let g:tcomment_types = {
      \'php_surround' : "<?php %s ?>",
      \'eruby_surround' : "<%% %s %%>",
      \'eruby_surround_minus' : "<%% %s -%%>",
      \'eruby_surround_equality' : "<%%= %s %%>",
\}

" マッピングを追加
"  <C-_>= => <%= %>でトグル
"  <C-_>- => <% -%>でトグル
"  <C-_>c => ファイル形式から、<?php ?>か<% %>でトグル

" function! SetErubyMapping2()
"   nmap <buffer> <C-_>c :TCommentAs eruby_surround<CR>
"   nmap <buffer> <C-_>- :TCommentAs eruby_surround_minus<CR>
"   nmap <buffer> <C-_>= :TCommentAs eruby_surround_equality<CR>
" 
"   vmap <buffer> <C-_>c :TCommentAs eruby_surround<CR>
"   vmap <buffer> <C-_>- :TCommentAs eruby_surround_minus<CR>
"   vmap <buffer> <C-_>= :TCommentAs eruby_surround_equality<CR>
" endfunction
" 
" " erubyのときだけ設定を追加
" au FileType eruby call SetErubyMapping2()



"-------------------------------------------------------------------------------
" IndentGuide
"-------------------------------------------------------------------------------

" hi IndentGuidesOdd  ctermbg=black
" hi IndentGuidesEven ctermbg=darkgrey

"-------------------------------------------------------------------------------

  let g:winresizer_start_key = '<C-b>'
  let g:winresizer_keycode_cancel = 122
  let g:winresizer_vert_resize = 3

" Gundo

let g:gundo_width = 60
let g:gundo_preview_height = 40
let g:gundo_right = 1
nnoremap g; :GundoToggle<CR>


"-------------------------------------------------------------------------------
" NeoSnippet
"-------------------------------------------------------------------------------


" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif


"-------------------------------------------------------------------------------
" vim-browserreload-mac
"-------------------------------------------------------------------------------
" リロード後に戻ってくるアプリ 変更してください
let g:returnApp = "iTerm"
nmap <Space>bc :ChromeReloadStart<CR>
nmap <Space>bC :ChromeReloadStop<CR>
" nmap <Space>bf :FirefoxReloadStart<CR>
" nmap <Space>bF :FirefoxReloadStop<CR>
" nmap <Space>bs :SafariReloadStart<CR>
" nmap <Space>bS :SafariReloadStop<CR>
" nmap <Space>bo :OperaReloadStart<CR>
" nmap <Space>bO :OperaReloadStop<CR>
" nmap <Space>ba :AllBrowserReloadStart<CR>
" nmap <Space>bA :AllBrowserReloadStop<CR>

"-------------------------------------------------------------------------------
" Xdebug
"-------------------------------------------------------------------------------

let g:vdebug_options = {
\    "break_on_open" : 0,
\    "continuous_mode"  : 1,
\}

